<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>3D Motion Lab ‚Äî Joint Trainer</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<style>
:root{--bg:#0b1220;--panel:#0f172a;--line:#1f2937;--ctrl:#1e293b;--text:#e2e8f0;--muted:#cbd5e1}
html,body{margin:0;height:100%;background:var(--bg);color:var(--text);overflow:hidden;font-family:system-ui,Segoe UI,Roboto}
canvas{position:fixed;inset:0;width:100%;height:100%;display:block}
.panel{position:fixed;left:12px;top:12px;width:360px;max-height:90vh;z-index:20;background:var(--panel);border:1px solid var(--line);border-radius:12px;box-shadow:0 8px 28px rgba(0,0,0,.4);display:flex;flex-direction:column;overflow:hidden}
.dragbar{cursor:move;background:#0c1628;border-bottom:1px solid #162235;padding:8px 12px;font-weight:700;display:flex;align-items:center;gap:8px}
.dragbar .hint{margin-left:auto;font-size:12px;color:#9fb0c9}
.content{padding:12px;overflow:auto}
label{display:block;font-size:12px;margin-top:8px;color:var(--muted)}
select,button,input[type=range]{width:100%;margin:6px 0 8px 0;padding:8px 10px;border-radius:10px;background:var(--ctrl);border:1px solid #334155;color:var(--text)}
.row{display:flex;gap:8px}.row>button{flex:1}
.mini{padding:6px 10px;border-radius:8px;background:var(--ctrl);border:1px solid #334155}
.seg{display:flex;gap:8px}
.seg button{flex:1;padding:8px 10px;border-radius:10px;background:#142033;border:1px solid #334155;color:#cbd5e1}
.seg button.on{background:#1f2c43;color:#fff;border-color:#47618e}
details{border:1px solid #162235;border-radius:10px;padding:8px;background:#0b1426;margin-top:8px}
summary{cursor:pointer;font-weight:600;color:#dbe7ff}
#log{background:#0b1220;border:1px solid #1f2937;min-height:90px;max-height:130px;overflow:auto;border-radius:8px;padding:8px;font-size:12px;white-space:pre-wrap}
#msg{position:fixed;bottom:10px;left:12px;background:rgba(15,23,42,.75);border:1px solid #334155;border-radius:8px;padding:6px 10px;font-size:12px;z-index:25}
optgroup{color:#9fb0c9;font-style:normal}
.modal{position:fixed;right:16px;bottom:16px;width:min(560px,92vw);max-height:78vh;z-index:30;background:rgba(8,13,26,.96);border:1px solid #334155;border-radius:12px;backdrop-filter:blur(6px);display:none;flex-direction:column;overflow:hidden}
.modal.on{display:flex}
.modal .top{display:flex;align-items:center;gap:10px;padding:10px 12px;border-bottom:1px solid #1f2a40;background:#0c1628}
.modal .top h4{margin:0;font-size:14px}
.modal .x{margin-left:auto;background:transparent;border:0;color:#9fb0c9;font-size:18px;cursor:pointer}
.modal .body{padding:12px;overflow:auto}
</style>
</head>
<body>
  <div class="panel" id="panel">
    <div class="dragbar" id="dragbar">üß≠ Joint Lab</div>
    <div class="content">
      <div class="row">
        <button id="reload" class="mini">Reload Model</button>
        <button id="fit" class="mini">Fit View</button>
        <button id="romBtn" class="mini">üìò ROM Reference</button>
      </div>

      <label>Posture</label>
      <div class="row">
        <select id="postureSel">
          <option value="stand">Stand (neutral)</option>
          <option value="sit">Sit 90/90</option>
          <option value="supine">Supine</option>
          <option value="prone">Prone</option>
        </select>
        <button id="applyPosture" class="mini" style="flex:0 0 34%">Apply</button>
      </div>
      <div class="row"><button id="zeroAll" class="mini">Zero All Joints</button></div>

      <label>Body Region</label>
      <div class="seg">
        <button id="segUpper" class="on">Upper Body</button>
        <button id="segLower">Lower Body</button>
      </div>

      <label>Action (Paired Motion)</label>
      <select id="actionSel"></select>

      <label><span id="pairLabel">Angle (¬∞)</span></label>
      <input type="range" id="actionDeg" min="-90" max="150" step="1" value="0">
      
      <div class="row" id="dirRow" style="align-items:center;gap:12px">
        <label style="margin:0;min-width:140px">Direction</label>
        <label><input type="radio" name="dir" value="pos" checked> Flexion/Abduction/External</label>
        <label><input type="radio" name="dir" value="neg"> Extension/Adduction/Internal</label>
      </div>

      <div class="row">
        <button id="zeroAction" class="mini">Zero Motion</button>
      </div>
      <div class="row">
        <button id="testAction" class="mini">Test</button>
        <div style="display:flex;gap:8px;align-items:center;flex:1">
          <label style="margin:0;min-width:60px">Force</label>
          <input type="range" id="forceLvl" min="0" max="5" step="1" value="0" style="flex:1">
          <span id="forceVal" style="width:2ch;text-align:right">0</span>
        </div>
      </div>
      
      <div class="row" id="poseRow" style="align-items:center;gap:8px">
        <label style="margin:0;min-width:140px">Posture</label>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button id="pose_supine" class="mini">Supine</button>
          <button id="pose_prone" class="mini">Prone</button>
          <button id="pose_sitting" class="mini">Sitting</button>
        </div>
      </div>

      <div class="row" id="rangeRow" style="align-items:center;gap:10px">
        <label style="margin:0;min-width:140px">Range Gauge</label>
        <div id="rangeGauge" style="height:14px;border-radius:8px;flex:1;background:linear-gradient(90deg,#16a34a 0 60%, #f59e0b 60% 85%, #ef4444 85% 100%); position:relative">
          <div id="rangeMarker" style="position:absolute;top:-4px;width:2px;height:22px;background:#e2e8f0;left:50%"></div>
        </div>
        <label style="display:flex;align-items:center;gap:6px;margin:0"><input type="checkbox" id="lockRange" checked> Lock to normal</label>
      </div>


      <details>
        <summary>Bone (Advanced)</summary>
        <label>Bone (auto-detected)</label>
        <select id="boneSel"></select>
        <div class="row">
          <div style="flex:1">
            <label>Rotate X (¬∞)</label>
            <input type="range" min="-180" max="180" step="1" value="0" id="rx">
          </div>
          <div style="flex:1">
            <label>Rotate Y (¬∞)</label>
            <input type="range" min="-180" max="180" step="1" value="0" id="ry">
          </div>
        </div>
        <label>Rotate Z (¬∞)</label>
        <input type="range" min="-180" max="180" step="1" value="0" id="rz">
        <div class="row"><button id="zeroBone" class="mini">Zero Bone</button></div>
      </details>

      <details>
        <summary>Model</summary>
        <div class="row">
          <div style="flex:1">
            <label>Model X (m)</label>
            <input type="range" min="-2" max="2" step="0.01" value="0" id="mx">
          </div>
          <div style="flex:1">
            <label>Model Z (m)</label>
            <input type="range" min="-2" max="2" step="0.01" value="0.6" id="mz">
          </div>
        </div>
        <div class="row">
          <div style="flex:1">
            <label>Model Y (m)</label>
            <input type="range" min="-0.2" max="0.6" step="0.005" value="0" id="my">
          </div>
          <div style="flex:1">
            <label>Scale (%)</label>
            <input type="range" min="40" max="200" step="1" value="100" id="ms">
          </div>
        </div>
        <label>Yaw (¬∞)</label>
        <input type="range" min="0" max="360" step="1" value="0" id="myaw">
        <div class="row"><button id="resetModel" class="mini">Reset Model</button></div>
      </details>

      <label>Event Log</label>
      <pre id="log"></pre>
    </div>
  </div>

  <div class="modal" id="romModal" aria-modal="true" role="dialog">
    <div class="top">
      <h4>ROM Reference</h4>
      <button class="x" id="romClose" aria-label="Close">‚úï</button>
    </div>
    <div class="body" id="romBody">Loading‚Ä¶</div>
  </div>

  <div id="msg">Loading‚Ä¶</div>
  <canvas id="c"></canvas>

  <script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
  import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
  import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";

  /* ===== UI ===== */
  const msg = document.getElementById("msg");
  const logEl = document.getElementById("log");
  const log = (t)=>{ logEl.textContent += t + "\n"; logEl.scrollTop = logEl.scrollHeight; };

  const panel = document.getElementById("panel");
  const dragbar = document.getElementById("dragbar");
  const reloadBtn = document.getElementById("reload");
  const fitBtn = document.getElementById("fit");
  const romBtn = document.getElementById("romBtn");
  const romModal = document.getElementById("romModal");
  const romBody = document.getElementById("romBody");
  const romClose = document.getElementById("romClose");

  const postureSel = document.getElementById("postureSel");
  const applyPosture = document.getElementById("applyPosture");
  const zeroAll = document.getElementById("zeroAll");

  const segUpper = document.getElementById("segUpper");
  const segLower = document.getElementById("segLower");

  const actionSel = document.getElementById("actionSel");
  const actionDeg = document.getElementById("actionDeg");
  const pairLabel = document.getElementById("pairLabel");
  const zeroAction = document.getElementById("zeroAction");

  const boneSel = document.getElementById("boneSel");
  const rx = document.getElementById("rx");
  const ry = document.getElementById("ry");
  const rz = document.getElementById("rz");
  const zeroBone = document.getElementById("zeroBone");

  const mx = document.getElementById("mx");
  const my = document.getElementById("my");
  const mz = document.getElementById("mz");
  const ms = document.getElementById("ms");
  const myaw = document.getElementById("myaw");
  const resetModel = document.getElementById("resetModel");

  /* ===== Draggable panel ===== */
  (function(){
    let dragging=false, sx=0, sy=0, startLeft=0, startTop=0;
    const onDown = (e)=>{ dragging=true; sx=e.clientX; sy=e.clientY;
      const r = panel.getBoundingClientRect();
      startLeft = r.left; startTop = r.top;
      e.preventDefault();
    };
    const onMove = (e)=>{ if(!dragging) return;
      const dx = e.clientX - sx, dy = e.clientY - sy;
      panel.style.left = Math.max(8, startLeft + dx) + "px";
      panel.style.top = Math.max(8, startTop + dy) + "px";
    };
    const onUp = ()=>{ dragging = false; };
    dragbar.addEventListener("pointerdown", onDown);
    window.addEventListener("pointermove", onMove);
    window.addEventListener("pointerup", onUp);
  })();

  /* ===== Three setup ===== */
  const canvas = document.getElementById("c");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(devicePixelRatio);
  renderer.setSize(innerWidth, innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1220);

  const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 100);
  camera.position.set(1.6, 1.6, 2.8);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; controls.dampingFactor = 0.08;
  controls.minDistance = 0.6; controls.maxDistance = 6;
  controls.target.set(0,1.1,0);

  scene.add(new THREE.HemisphereLight(0xffffff, 0x333344, 0.7));
  const key = new THREE.DirectionalLight(0xffffff, 1.2);
  key.position.set(2.5,4,2.5);
  key.castShadow = true;
  key.shadow.mapSize.set(2048,2048);
  key.shadow.camera.near = 0.1; key.shadow.camera.far = 15;
  key.shadow.camera.left = -4; key.shadow.camera.right = 4; key.shadow.camera.top = 4; key.shadow.camera.bottom = -4;
  scene.add(key);

  const ground = new THREE.Mesh(new THREE.PlaneGeometry(20,20), new THREE.ShadowMaterial({ opacity: 0.45 }));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

  /* ===== Loader ===== */
  const loader = new GLTFLoader();
  loader.setMeshoptDecoder(MeshoptDecoder);
  const draco = new DRACOLoader(); draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/"); loader.setDRACOLoader(draco);
  const ktx2 = new KTX2Loader(); ktx2.setTranscoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/"); ktx2.detectSupport(renderer); loader.setKTX2Loader(ktx2);

  let model = null, skeleton = null;
  const initialBoneRot = new Map();

  function pickModelUrl(){
    const u = new URL(location.href);
    const q = u.searchParams.get("model");
    if (q && /^https?:\/\//i.test(q)) return q;
    if (q && q.trim()) return new URL(q, location.href).href;
    return "./Athletic_Grace_1006002620_texture.glb";
  }
  let MODEL_URL = pickModelUrl();

  function groundSnap(){
    if (!model) return;
    const box = new THREE.Box3().setFromObject(model);
    const minY = box.min.y;
    if (isFinite(minY)) model.position.y -= minY;
  }
  function autoScaleToHeight(target=1.75){
    const box = new THREE.Box3().setFromObject(model);
    const h = box.max.y - box.min.y;
    if (!isFinite(h) || h <= 0) return;
    const s = target / h;
    if (s < 0.4 || s > 2.5) { model.scale.multiplyScalar(s); log(`Scaled √ó${s.toFixed(2)}`); }
  }
  function fitView(){
    const box = new THREE.Box3().setFromObject(model || scene);
    const size = new THREE.Vector3(); box.getSize(size);
    const center = new THREE.Vector3(); box.getCenter(center);
    controls.target.copy(center);
    const maxDim = Math.max(size.x, size.y, size.z);
    const dist = maxDim / (2 * Math.tan((camera.fov * Math.PI/180)/2));
    camera.position.copy(center).add(new THREE.Vector3(0.8*dist, 0.8*dist, 1.2*dist));
    camera.lookAt(center);
  }

  /* ===== Populate bones ===== */
  function populateBones(){
    boneSel.innerHTML = "";
    if (!skeleton) {
      const o = document.createElement("option");
      o.value = ""; o.textContent = "(No skeleton)";
      boneSel.appendChild(o);
      return;
    }
    skeleton.bones.forEach((b,i)=>{
      const o = document.createElement("option");
      o.value = String(i);
      o.textContent = b.name || `Bone ${i}`;
      boneSel.appendChild(o);
      if (!initialBoneRot.has(b)) initialBoneRot.set(b, b.quaternion.clone());
    });
    if (skeleton.bones.length) boneSel.value = "0";
    rx.value = "0"; ry.value = "0"; rz.value = "0";
    setBoneRotationFromUI();
  }
  function setBoneRotationFromUI(){
    const idx = parseInt(boneSel.value||"-1",10);
    if (!skeleton || isNaN(idx) || !skeleton.bones[idx]) return;
    const b = skeleton.bones[idx];
    const ex = THREE.MathUtils.degToRad(parseFloat(rx.value)||0);
    const ey = THREE.MathUtils.degToRad(parseFloat(ry.value)||0);
    const ez = THREE.MathUtils.degToRad(parseFloat(rz.value)||0);
    const qDelta = new THREE.Quaternion().setFromEuler(new THREE.Euler(ex,ey,ez,"XYZ"));
    const qBase = initialBoneRot.get(b) || new THREE.Quaternion();
    b.quaternion.copy(qBase).multiply(qDelta);
  }
  function zeroSelectedBone(){
    const idx = parseInt(boneSel.value||"-1",10);
    if (!skeleton || isNaN(idx) || !skeleton.bones[idx]) return;
    const b = skeleton.bones[idx];
    const qb = initialBoneRot.get(b);
    if (qb) b.quaternion.copy(qb);
    rx.value="0"; ry.value="0"; rz.value="0";
  }

  /* ===== Rig profile detection & axis map ===== */
  let RIG_PROFILE = 'generic';
  function detectRigProfile(){
    const names = skeleton?.bones.map(b=>b.name.toLowerCase()).join(' ') || '';
    if (/\bmixamorig\b/.test(names)) RIG_PROFILE = 'mixamo';
    else RIG_PROFILE = 'generic';
    log(`Rig profile: ${RIG_PROFILE}`);
  }

  // Return the local axis to drive for a given motion key under a profile
  function axisFor(profile, motionKey, defaultAxis){
    if (profile==='mixamo'){
      // Corrected Mixamo local axes
      const map = {
        // Shoulder (GH)
        sh_fe_l:'x', sh_fe_r:'x',           // flex / ext ‚Üí sagittal
        sh_aa_l:'z', sh_aa_r:'z',           // abd / add  ‚Üí frontal
        sh_irer_l:'y', sh_irer_r:'y',       // IR / ER    ‚Üí transverse

        // Elbow (humeroulnar)
        el_fe_l:'x', el_fe_r:'x',           // flex / ext

        // Forearm
        fa_ps_l:'y', fa_ps_r:'y',           // pronation / supination

        // Wrist
        wr_fe_l:'x', wr_fe_r:'x',           // flex / ext
        wr_ru_l:'z', wr_ru_r:'z',           // radial / ulnar deviation

        // Hip
        hip_fe_l:'x', hip_fe_r:'x',         // flex / ext
        hip_aa_l:'z', hip_aa_r:'z',         // abd / add
        hip_irer_l:'y', hip_irer_r:'y',     // IR / ER

        // Knee
        knee_fe_l:'x', knee_fe_r:'x',       // flex / ext

        // Ankle / foot
        ankle_dfpf_l:'x', ankle_dfpf_r:'x', // dorsi / plantarflex
        foot_invev_l:'z', foot_invev_r:'z'  // inversion / eversion
      };
      if (motionKey in map) return map[motionKey];
    }
    // Generic fallback: use plane mapping
    return defaultAxis;
  }

  /* ===== Side-aware bone finding (no wrong-side fallback) ===== */
  const EXCLUDE = /(pelvis|root|spine|clavicle|scapula)/i;

  function sideRegex(side){
    if (!side) return [/.*/];
    if (side==='l'){
      return [
        /\bleft\b/i, /\b_left\b/i, /\.l\b/i, /_l\b/i, /\bl\b(?![a-z])/i,
        /\bleft(?=[A-Z_])/i, /mixamorig:.*left/i
      ];
    } else {
      return [
        /\bright\b/i, /\b_right\b/i, /\.r\b/i, /_r\b/i, /\br\b(?![a-z])/i,
        /\bright(?=[A-Z_])/i, /mixamorig:.*right/i
      ];
    }
  }

  function findBoneBy(cfg){
    if (!skeleton) return null;
    const names = skeleton.bones.map(b=>b.name.toLowerCase());
    const sideREs = sideRegex(cfg.side);
    // First pass: must match side (if specified) AND hint
    for (const cand of cfg.hints){
      for (let i=0;i<names.length;i++){
        if (EXCLUDE.test(names[i])) continue;
        if (!sideREs.some(r=>r.test(names[i]))) continue;
        if (cand.test(names[i])) return skeleton.bones[i];
      }
    }
    // Second pass (only when no side specified): hint only
    if (!cfg.side){
      for (const cand of cfg.hints){
        for (let i=0;i<names.length;i++){
          if (EXCLUDE.test(names[i])) continue;
          if (cand.test(names[i])) return skeleton.bones[i];
        }
      }
    }
    return null;
  }

  const JOINT_BIND = new Map();

  /* ===== Neutral calibration helpers (NEW) ===== */
  function axisCharToVec(axis){
    if (axis==='x') return new THREE.Vector3(1,0,0);
    if (axis==='y') return new THREE.Vector3(0,1,0);
    return new THREE.Vector3(0,0,1);
  }

  // Extract signed twist angle of q around local axis v (swing-twist split)
  function twistAngleAroundAxis(q, v){
    // q must be unit quaternion; v must be normalized axis in local space
    const vx = v.x, vy = v.y, vz = v.z;
    const s = vx*q.x + vy*q.y + vz*q.z;             // projection of q‚Äôs vector part
    // twist quaternion = normalize( [v*s, q.w] )
    let tx = vx*s, ty = vy*s, tz = vz*s, tw = q.w;
    const len = Math.hypot(tx,ty,tz,tw);
    if (len > 0) { tx/=len; ty/=len; tz/=len; tw/=len; }
    const sinHalf = Math.hypot(tx,ty,tz);
    let angle = 2*Math.atan2(sinHalf, Math.max(-1, Math.min(1, tw)));
    // sign based on direction along v
    const dot = tx*vx + ty*vy + tz*vz;
    if (dot < 0) angle = -angle;
    return angle; // radians
  }

  /* ===== Bind resolver with neutral shift (UPDATED) ===== */
  function resolveBind(key,cfg){
    if (JOINT_BIND.has(key)) return JOINT_BIND.get(key);
    const bone = findBoneBy(cfg);
    if (!bone) { log(`No bind for ${key}`); return null; }

    // Store bind (rest) orientation
    const qBind = (initialBoneRot.get(bone) || bone.quaternion.clone()).clone();

    // Determine driving axis for this motion
    const baseAxis = ({sagittal:'x', frontal:'z', transverse:'y'})[cfg.plane] || 'x';
    const axis = axisFor(RIG_PROFILE, key, baseAxis);

    // Compute relative bind rotation vs parent, then the twist angle around that axis.
    let neutralShiftDeg = 0;
    try{
      const parent = bone.parent && bone.parent.isBone ? bone.parent : null;
      const qp = parent ? (initialBoneRot.get(parent) || parent.quaternion.clone()).clone()
                        : new THREE.Quaternion(); // identity if no parent
      const qRel = qp.clone().invert().multiply(qBind); // parent‚Üíchild rotation at rest
      const v = axisCharToVec(axis);
      const ang = twistAngleAroundAxis(qRel, v); // radians (signed)
      neutralShiftDeg = THREE.MathUtils.radToDeg(-ang); // negate to zero it out
    }catch(e){ neutralShiftDeg = 0; }

    const obj = {bone, qBind, axis, neutralShiftDeg};
    JOINT_BIND.set(key,obj);
    log(`Bound ${key} ‚Üí ${bone.name} (axis ${axis}, neutralShift ${neutralShiftDeg.toFixed(1)}¬∞)`);
    return obj;
  }

  /* ===== Apply motion using calibrated neutral (UPDATED) ===== */
  function applyPairAngle(key,cfg,sliderDeg){
    const bind = resolveBind(key,cfg);
    if (!bind) return;
    const {bone, qBind, axis, neutralShiftDeg} = bind;

    const rad = THREE.MathUtils.degToRad(sliderDeg + (cfg.neutral||0) + (neutralShiftDeg||0));
    const e = new THREE.Euler(0,0,0,"XYZ");
    if (axis==='x') e.set(rad,0,0,"XYZ");
    if (axis==='y') e.set(0,rad,0,"XYZ");
    if (axis==='z') e.set(0,0,rad,"XYZ");

    const qDelta = new THREE.Quaternion().setFromEuler(e);
    bone.quaternion.copy(qBind).multiply(qDelta);
  }

  /* ===== Joint definitions (paired) ===== */
  // Hints prefer specific limb bones (avoid scapula/clavicle for GH; avoid forearm for wrist)
  const UPPER = [
    // NEW trunk/thoracic motions
    {key:'trunk_fe',  pair:'Trunk ‚Äî Flex / Ext',            side:'', plane:'sagittal',   neutral:0, min:-60, max:80,  hints:[/spine|chest|thor/i]},
    {key:'trunk_lat', pair:'Trunk ‚Äî Lateral Bend (L / R)',  side:'', plane:'frontal',    neutral:0, min:-40, max:40,  hints:[/spine|chest|thor/i]},
    {key:'trunk_rot', pair:'Trunk ‚Äî Rotation (L / R)',      side:'', plane:'transverse', neutral:0, min:-45, max:45,  hints:[/spine|chest|thor/i]},

    // Cervical
    {key:'cerv_fe',   pair:'Cervical Flex / Ext',                side:'', plane:'sagittal',   neutral:0, min:-60,  max:70,  hints:[/neck|cspine|head/i]},
    {key:'cerv_lat',  pair:'Cervical Lat Flex (L / R)',          side:'', plane:'frontal',    neutral:0, min:-45,  max:45,  hints:[/neck|cspine|head/i]},
    {key:'cerv_rot',  pair:'Cervical Rotation (L / R)',          side:'', plane:'transverse', neutral:0, min:-80,  max:80,  hints:[/neck|cspine|head/i]},

    // Shoulder
    {key:'sh_fe_l',   pair:'Shoulder L ‚Äî Flex / Ext',            side:'l', plane:'sagittal',  neutral:0, min:-180, max:60,  hints:[/upper.?arm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_fe_r',   pair:'Shoulder R ‚Äî Flex / Ext',            side:'r', plane:'sagittal',  neutral:0, min:-180, max:60,  hints:[/upper.?arm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_aa_l',   pair:'Shoulder L ‚Äî Abd / Add',             side:'l', plane:'frontal',   neutral:0, min:-180, max:40,  hints:[/upper.?arm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_aa_r',   pair:'Shoulder R ‚Äî Abd / Add',             side:'r', plane:'frontal',   neutral:0, min:-180, max:40,  hints:[/upper.?arm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_irer_l', pair:'Shoulder L ‚Äî Internal / External',   side:'l', plane:'transverse',neutral:0, min:-70,  max:90,  hints:[/upper.?arm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_irer_r', pair:'Shoulder R ‚Äî Internal / External',   side:'r', plane:'transverse',neutral:0, min:-70,  max:90,  hints:[/upper.?arm|humerus|shoulder|arm(?!.*lower)/i]},

    // Elbow / Forearm
    {key:'el_fe_l',   pair:'Elbow L ‚Äî Flex / Ext',               side:'l', plane:'sagittal',  neutral:0, min:-150, max:10,  hints:[/lower.?arm|forearm|ulna|radius/i]},
    {key:'el_fe_r',   pair:'Elbow R ‚Äî Flex / Ext',               side:'r', plane:'sagittal',  neutral:0, min:-150, max:10,  hints:[/lower.?arm|forearm|ulna|radius/i]},
    {key:'fa_ps_l',   pair:'Forearm L ‚Äî Pronation / Supination', side:'l', plane:'transverse',neutral:0, min:-85,  max:95,  hints:[/lower.?arm|forearm|ulna|radius/i]},
    {key:'fa_ps_r',   pair:'Forearm R ‚Äî Pronation / Supination', side:'r', plane:'transverse',neutral:0, min:-85,  max:95,  hints:[/lower.?arm|forearm|ulna|radius/i]},

    // Wrist
    {key:'wr_fe_l',   pair:'Wrist L ‚Äî Flex / Ext',               side:'l', plane:'sagittal',  neutral:0, min:-80,  max:70,  hints:[/wrist|hand(?!.*thumb|.*index|.*middle|.*ring|.*pinky)/i]},
    {key:'wr_fe_r',   pair:'Wrist R ‚Äî Flex / Ext',               side:'r', plane:'sagittal',  neutral:0, min:-80,  max:70,  hints:[/wrist|hand(?!.*thumb|.*index|.*middle|.*ring|.*pinky)/i]},
    {key:'wr_ru_l',   pair:'Wrist L ‚Äî Radial / Ulnar Dev',       side:'l', plane:'frontal',   neutral:0, min:-20,  max:40,  hints:[/wrist|hand(?!.*thumb|.*index|.*middle|.*ring|.*pinky)/i]},
    {key:'wr_ru_r',   pair:'Wrist R ‚Äî Radial / Ulnar Dev',       side:'r', plane:'frontal',   neutral:0, min:-20,  max:40,  hints:[/wrist|hand(?!.*thumb|.*index|.*middle|.*ring|.*pinky)/i]},
  ];

  const LOWER = [
    {key:'hip_fe_l',   pair:'Hip L ‚Äî Flex / Ext',                side:'l', plane:'sagittal',  neutral:0, min:-120, max:30,  hints:[/upper.?leg|thigh|femur/i]},
    {key:'hip_fe_r',   pair:'Hip R ‚Äî Flex / Ext',                side:'r', plane:'sagittal',  neutral:0, min:-120, max:30,  hints:[/upper.?leg|thigh|femur/i]},
    {key:'hip_aa_l',   pair:'Hip L ‚Äî Abd / Add',                 side:'l', plane:'frontal',   neutral:0, min:-45,  max:30,  hints:[/upper.?leg|thigh|femur/i]},
    {key:'hip_aa_r',   pair:'Hip R ‚Äî Abd / Add',                 side:'r', plane:'frontal',   neutral:0, min:-45,  max:30,  hints:[/upper.?leg|thigh|femur/i]},
    {key:'hip_irer_l', pair:'Hip L ‚Äî Internal / External',       side:'l', plane:'transverse',neutral:0, min:-45,  max:45,  hints:[/upper.?leg|thigh|femur/i]},
    {key:'hip_irer_r', pair:'Hip R ‚Äî Internal / External',       side:'r', plane:'transverse',neutral:0, min:-45,  max:45,  hints:[/upper.?leg|thigh|femur/i]},

    {key:'knee_fe_l',  pair:'Knee L ‚Äî Flex / Ext',               side:'l', plane:'sagittal',  neutral:0, min:-150, max:5,   hints:[/lower.?leg|calf|shin|tibia|fibula/i]},
    {key:'knee_fe_r',  pair:'Knee R ‚Äî Flex / Ext',               side:'r', plane:'sagittal',  neutral:0, min:-150, max:5,   hints:[/lower.?leg|calf|shin|tibia|fibula/i]},

    {key:'ankle_dfpf_l', pair:'Ankle L ‚Äî Dorsi / Plantarflex',   side:'l', plane:'sagittal',  neutral:0, min:-20,  max:50,  hints:[/ankle|foot|talus|tarsal/i]},
    {key:'ankle_dfpf_r', pair:'Ankle R ‚Äî Dorsi / Plantarflex',   side:'r', plane:'sagittal',  neutral:0, min:-20,  max:50,  hints:[/ankle|foot|talus|tarsal/i]},
    {key:'foot_invev_l', pair:'Foot L ‚Äî Inversion / Eversion',   side:'l', plane:'frontal',   neutral:0, min:-20,  max:35,  hints:[/foot|calcaneus|heel|metatars/i]},
    {key:'foot_invev_r', pair:'Foot R ‚Äî Inversion / Eversion',   side:'r', plane:'frontal',   neutral:0, min:-20,  max:35,  hints:[/foot|calcaneus|heel|metatars/i]},
  ];

  let CURRENT = UPPER;

  /* ===== UI: actions ===== */
  function fillActionMenu(){
    actionSel.innerHTML = "";
    const list = (CURRENT===UPPER) ? UPPER : LOWER;
    const og = document.createElement("optgroup");
    og.label = (CURRENT===UPPER) ? "Cervical, Trunk, Shoulder & Arm" : "Hip, Leg & Foot";
    for (const item of list){
      const opt = document.createElement("option");
      opt.value = item.key;
      opt.textContent = item.pair;
      og.appendChild(opt);
    }
    actionSel.appendChild(og);
    const first = actionSel.querySelector('option');
    if (first) actionSel.value = first.value;
    syncActionUI(true);
  }

  function cfgFromKey(k){
    const list = (CURRENT===UPPER) ? UPPER : LOWER;
    return list.find(x=>x.key===k) || null;
  }

  function syncActionUI(forceZero=false){
    const key = actionSel.value;
    const cfg = cfgFromKey(key);
    if (!cfg) return;
    pairLabel.textContent = cfg.pair + " ‚Äî Angle (¬∞)";
    actionDeg.min = String(cfg.min);
    actionDeg.max = String(cfg.max);
    if (forceZero) actionDeg.value = "0";
    // ensure neutral baseline applied immediately
    applyPairAngle(key, cfg, parseFloat(actionDeg.value)||0);
  }

  /* ===== Postures ===== */
  function rotateBoneDelta(b, x=0, y=0, z=0){
    const qb = (initialBoneRot.get(b) || b.quaternion.clone()).clone();
    const dq = new THREE.Quaternion().setFromEuler(new THREE.Euler(
      THREE.MathUtils.degToRad(x),
      THREE.MathUtils.degToRad(y),
      THREE.MathUtils.degToRad(z),
      "XYZ"
    ));
    b.quaternion.copy(qb).multiply(dq);
  }
  function findOne(reList){
    if (!skeleton) return null;
    const names = skeleton.bones.map(b=>b.name.toLowerCase());
    for (const re of reList){
      const i = names.findIndex(n => re.test(n));
      if (i >= 0) return skeleton.bones[i];
    }
    return null;
  }

  function zeroAllJoints(){
    for (const [,bind] of JOINT_BIND.entries()){
      bind.bone.quaternion.copy(bind.qBind);
    }
    actionDeg.value = "0";
    log("Zero all motions");
  }

  function applyPosturePreset(kind){
    zeroAllJoints();

    if (kind === "stand"){
      model.rotation.x = 0;
      groundSnap(); fitView(); return;
    }
    if (kind === "sit"){
      // Mixamo-friendly names
      const Lhip = findOne([/upper.?leg_l|thigh_l|femur_l|mixamorig:lefthip|mixamorig:leftupleg/i, /left upleg/i]);
      const Rhip = findOne([/upper.?leg_r|thigh_r|femur_r|mixamorig:righthip|mixamorig:rightupleg/i, /right upleg/i]);
      const Lk = findOne([/lower.?leg_l|tibia_l|shin_l|calf_l|mixamorig:leftleg/i]);
      const Rk = findOne([/lower.?leg_r|tibia_r|shin_r|calf_r|mixamorig:rightleg/i]);
      const Lank = findOne([/foot.*l|ankle.*l|talus.*l|tarsal.*l|mixamorig:leftfoot/i]);
      const Rank = findOne([/foot.*r|ankle.*r|talus.*r|tarsal.*r|mixamorig:rightfoot/i]);

      if (Lhip) rotateBoneDelta(Lhip, -90,0,0);
      if (Rhip) rotateBoneDelta(Rhip, -90,0,0);
      if (Lk) rotateBoneDelta(Lk, -90,0,0);
      if (Rk) rotateBoneDelta(Rk, -90,0,0);
      if (Lank) rotateBoneDelta(Lank, +5,0,0);
      if (Rank) rotateBoneDelta(Rank, +5,0,0);

      model.rotation.x = 0;
      groundSnap(); fitView(); return;
    }
    if (kind === "supine"){
      model.rotation.x = Math.PI/2;
      groundSnap(); fitView(); return;
    }
    if (kind === "prone"){
      model.rotation.x = -Math.PI/2;
      groundSnap(); fitView(); return;
    }
  }

  /* ===== Wire UI ===== */
  segUpper.onclick = ()=>{ CURRENT = UPPER; segUpper.classList.add('on'); segLower.classList.remove('on'); fillActionMenu(); };
  segLower.onclick = ()=>{ CURRENT = LOWER; segLower.classList.add('on'); segUpper.classList.remove('on'); fillActionMenu(); };

  actionSel.addEventListener("change", ()=>syncActionUI(true));
  actionDeg.addEventListener("input", ()=>{
    const key = actionSel.value; const cfg = cfgFromKey(key);
    if (cfg) applyPairAngle(key,cfg, parseFloat(actionDeg.value)||0);
  });

  zeroAction.onclick = ()=>{
    const key = actionSel.value; const cfg = cfgFromKey(key);
    if (!cfg) return;
    actionDeg.value = "0";
    applyPairAngle(key,cfg, 0);
  };

  boneSel.onchange = ()=>{ rx.value="0"; ry.value="0"; rz.value="0"; setBoneRotationFromUI(); };
  [rx,ry,rz].forEach(el=> el.addEventListener("input", setBoneRotationFromUI));

  [mx,my,mz,ms,myaw].forEach(el => el.addEventListener("input", () => {
    if (!model) return;
    model.position.set(parseFloat(mx.value), parseFloat(my.value), parseFloat(mz.value));
    model.scale.setScalar(parseInt(ms.value,10)/100);
    model.rotation.y = THREE.MathUtils.degToRad(parseFloat(myaw.value));
  }));
  zeroBone.onclick = zeroSelectedBone;
  resetModel.onclick = ()=>{
    mx.value="0"; my.value="0"; mz.value="0.6"; ms.value="100"; myaw.value="0";
    if (model){
      model.position.set(0,0,0.6);
      model.scale.setScalar(1);
      model.rotation.y = 0;
    }
    groundSnap(); fitView();
  };
  reloadBtn.onclick = ()=>{ MODEL_URL = pickModelUrl(); log(`Reload: ${MODEL_URL}`); loadModel(); };
  fitBtn.onclick = fitView;

  // ROM modal
  romBtn.onclick = async ()=>{
    romModal.classList.add('on');
    try{
      const res = await fetch('./ROM_reference.md?'+Date.now());
      const md = await res.text();
      romBody.innerHTML = md.replace(/^\- (.*)$/gm,'<li>$1</li>').replace(/(<li>[\s\S]*?<\/li>)/g,'<ul>$1</ul>').replace(/^# (.*)$/gm,'<h3>$1</h3>').replace(/^### (.*)$/gm,'<h4>$1</h4>').replace(/\*\*(.*?)\*\*/g,'<strong>$1</strong>');
    }catch(e){ romBody.textContent='Failed to load ROM_reference.md'; }
  };
  document.getElementById("romClose").onclick = ()=> romModal.classList.remove('on');



  // ----- Direction radio controls -----
  const dirRow = document.getElementById('dirRow');
  const dirInputs = dirRow ? dirRow.querySelectorAll('input[name="dir"]') : [];

  function currentSign(){
    let sign = 1;
    dirInputs.forEach(r => { if (r.checked) sign = (r.value==='neg') ? -1 : 1; });
    return sign;
  }
  dirInputs.forEach(r => r.addEventListener('change', () => {
    // Snap slider to same magnitude but new sign, clamped to allowed range
    const cfg = cfgFromKey(actionSel.value); if (!cfg) return;
    const mag = Math.abs(parseFloat(actionDeg.value)||0);
    let target = mag * currentSign();
    if (lockRange.checked){
      target = clamp(target, cfg.min, cfg.max);
    } else {
      target = clamp(target, -180, 180);
    }
    actionDeg.value = String(target);
    applyPairAngle(actionSel.value, cfg, target);
    updateGauge();
  }));

  // Hook Test button so it uses midrange toward the selected direction only.
  if (typeof testAction !== 'undefined'){
    testAction.replaceWith(testAction.cloneNode(true));
  }

  // Update force label
  forceLvl.addEventListener("input", ()=>{ forceVal.textContent = String(forceLvl.value); });

  // Expand or lock slider range
  
  // ----- Postures -----
  function setPose(name){
    // Utility to move common joints if they exist
    const tryApply = (key, deg)=>{ const cfg = cfgFromKey(key); if (cfg) applyPairAngle(key, cfg, deg); }

    if (name==='supine'){
      // Neutral joints, lying face up: hips/knees ~0, spine neutral
      ['hi_fe_l','hi_fe_r','kn_fe_l','kn_fe_r','sp_flex','an_df_l','an_df_r'].forEach(k=>tryApply(k, 0));
    }
    if (name==='prone'){
      // Face down; keep neutrals (this app is joint-only), small hip extension is OK
      tryApply('hi_fe_l', -10); tryApply('hi_fe_r', -10);
      ['kn_fe_l','kn_fe_r','sp_flex','an_df_l','an_df_r'].forEach(k=>tryApply(k, 0));
    }
    if (name==='sitting'){
      // 90-90-90 rule with slight lumbar flexion
      tryApply('hi_fe_l', 90); tryApply('hi_fe_r', 90);
      tryApply('kn_fe_l', 90); tryApply('kn_fe_r', 90);
      tryApply('an_df_l', 0);  tryApply('an_df_r', 0);
      tryApply('sp_flex', 10);
    }
  }

  const poseSup = document.getElementById('pose_supine');
  const posePro = document.getElementById('pose_prone');
  const poseSit = document.getElementById('pose_sitting');
  if (poseSup) poseSup.addEventListener('click', ()=>setPose('supine'));
  if (posePro) posePro.addEventListener('click', ()=>setPose('prone'));
  if (poseSit) poseSit.addEventListener('click', ()=>setPose('sitting'));

  function applyRangeLock(){
    const cfg = cfgFromKey(actionSel.value); if (!cfg) return;
    if (lockRange.checked){
      actionDeg.min = String(cfg.min); actionDeg.max = String(cfg.max);
      actionDeg.value = String(clamp(parseFloat(actionDeg.value)||0, cfg.min, cfg.max));
    }else{
      actionDeg.min = "-180"; actionDeg.max = "180";
    }
    updateGauge();
  }
  lockRange.addEventListener("change", applyRangeLock);

  actionDeg.addEventListener("input", updateGauge);
  actionSel.addEventListener("change", ()=>{ applyRangeLock(); updateGauge(); });

  function midRangeFor(cfg){
    // Prefer positive direction mid if available; else average of bounds
    if (cfg.max > 0) return Math.round(cfg.max/2);
    if (cfg.min < 0) return Math.round(cfg.min/2);
    return 0;
  }

  function testPrereqs(key){
    // For forearm pronation/supination, set elbow flex to ~90¬∞ first
    if (key === 'fa_ps_l'){
      const ecfg = UPPER.find(x=>x.key==='el_fe_l'); if (ecfg) applyPairAngle('el_fe_l', ecfg, -90); // elbow flexion often negative in our min/max
    }
    if (key === 'fa_ps_r'){
      const ecfg = UPPER.find(x=>x.key==='el_fe_r'); if (ecfg) applyPairAngle('el_fe_r', ecfg, -90);
    }
  }

  testAction.addEventListener("click", ()=>{
    const key = actionSel.value; const cfg = cfgFromKey(key); if (!cfg) return;
    testPrereqs(key);
    const target = Math.abs(midRangeFor(cfg)) * currentSign();
    actionDeg.value = String(target);
    applyPairAngle(key, cfg, target);
    updateGauge();
    log(`Test: ${cfg.pair} at ${target}¬∞ (Force ${forceLvl.value})`);
  });

  function updateGauge(){
    const v = parseFloat(actionDeg.value)||0;
    // just reposition the marker; background bands are static green‚Üíorange‚Üíred
    const pct = (Math.max(-180, Math.min(180, v)) + 180) / 360 * 100;
    rangeMarker.style.left = pct + "%";
  }


  // ===== Playbook-driven Test Engine =====
  function getPlaybook(){ 
    try{ return JSON.parse(document.getElementById('playbook').textContent); } catch(e){ console.warn(e); return null; }
  }
  const PB = getPlaybook();

  // utility to mirror keys *_l <-> *_r if needed
  function mirrorKey(key){
    if (key.endsWith('_l')) return key.replace(/_l$/, '_r');
    if (key.endsWith('_r')) return key.replace(/_r$/, '_l');
    return key;
  }

  function resolveTestName(key, direction){
    // Map UI action key + direction to a test name in PB.tests
    // Example: gh_fe_l + pos -> gh_flex_l ; gh_fe_l + neg -> gh_ext_l
    // We'll define a mapping for common labels:
    const map = {
      'gh_fe': ['gh_ext','gh_flex'],     // neg, pos
      'el_fe': ['el_ext','el_flex'],
      'fa_ps': ['fa_sup','fa_pro'],
      'cv_fe': ['cv_ext','cv_flex'],
      'cv_lat':['cv_lat_r','cv_lat_l'],
      'an_df': ['an_pf','an_df']
    };
    const base = key.replace(/_(l|r)$/, '');
    const side = key.endsWith('_r') ? '_r' : (key.endsWith('_l') ? '_l' : '');
    const pair = map[base];
    if (!pair) return null;
    const name = (direction > 0 ? pair[1] : pair[0]) + side;
    return name;
  }

  // tween helper
  function tweenAngle(key, cfg, fromDeg, toDeg, ms){
    return new Promise(res=>{
      const start = performance.now();
      function step(now){
        const t = Math.min(1, (now-start)/ms);
        const cur = fromDeg + (toDeg - fromDeg) * t;
        applyPairAngle(key, cfg, cur);
        if (t < 1) requestAnimationFrame(step); else res();
      }
      requestAnimationFrame(step);
    });
  }

  async function runPosture(name){
    if (!PB || !PB.postures || !PB.postures[name]) return;
    for (const step of PB.postures[name]){
      const cfg = cfgFromKey(step.key); if (!cfg) continue;
      const current = getCurrentAngle(step.key) || 0;
      await tweenAngle(step.key, cfg, current, step.deg, 300);
    }
  }

  async function runTestByName(name){
    if (!PB) return;
    // handle inheritance and mirroring
    let spec = PB.tests[name];
    if (!spec){
      console.warn('No test spec:', name);
      return;
    }
    if (spec.inherits){
      const base = JSON.parse(JSON.stringify(PB.tests[spec.inherits]));
      spec = Object.assign({}, base, spec);
    }
    // mirror step keys if flagged
    if (spec.mirror){
      if (spec.sequence){
        spec.sequence = spec.sequence.map(s => (s.key ? Object.assign({}, s, {key: mirrorKey(s.key)}) : s));
      }
    }
    if (spec.posture && spec.posture !== 'standing'){
      await runPosture(spec.posture);
    }
    // execute sequence
    for (const s of spec.sequence){
      if (s.type === 'call'){
        await runTestByName(s.name);
      }else if (s.type === 'move'){
        const cfg = cfgFromKey(s.key); if (!cfg) continue;
        const cur = getCurrentAngle(s.key) || 0;
        await tweenAngle(s.key, cfg, cur, s.deg, s.ms || 400);
      }
    }
  }

  function getCurrentAngle(key){
    // We keep current in the UI slider only for selected action, so we cache applied angles on window.
    window.__angles = window.__angles || {};
    return window.__angles[key];
  }
  // wrap applyPairAngle so we track current angles
  const __origApplyPairAngle = applyPairAngle;
  applyPairAngle = function(key, cfg, deg){
    window.__angles = window.__angles || {};
    window.__angles[key] = deg;
    __origApplyPairAngle(key, cfg, deg);
  }

  // Wire up Test to the playbook
  const _origTestHandler = async ()=>{};
  testAction.addEventListener('click', async (ev)=>{
    ev.preventDefault();
    const key = actionSel.value;
    const cfg = cfgFromKey(key); if (!cfg) return;
    const sign = currentSign();
    const name = resolveTestName(key, sign);
    if (!name){ console.warn('No mapping for', key); return; }
    await runTestByName(name);
  }, {once:false});

  /* ===== Load model ===== */
  function clearModel(){
    if (model) scene.remove(model);
    model = null; skeleton = null;
    initialBoneRot.clear(); JOINT_BIND.clear();
    boneSel.innerHTML = "";
  }
  function loadModel(){
    msg.textContent = "Loading‚Ä¶"; log("Loading model...");
    clearModel();
    loader.load(
      MODEL_URL,
      (gltf) => {
        model = gltf.scene;
        model.traverse(o => {
          if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; }
          if (o.isSkinnedMesh && !skeleton) skeleton = o.skeleton;
        });
        scene.add(model);
        model.position.set(parseFloat(mx.value), parseFloat(my.value), parseFloat(mz.value));
        model.scale.setScalar(parseInt(ms.value,10)/100);
        model.rotation.y = THREE.MathUtils.degToRad(parseFloat(myaw.value));
        groundSnap(); autoScaleToHeight(1.75); fitView();
        msg.textContent = "‚úÖ Model loaded";
        log("Model load OK");
        populateBones();
        detectRigProfile();
        CURRENT = UPPER;
        segUpper.classList.add('on'); segLower.classList.remove('on');
        fillActionMenu();
      },
      (xhr) => {
        msg.textContent = xhr.lengthComputable ? `Loading ${Math.round((xhr.loaded/xhr.total)*100)}%` : "Loading‚Ä¶";
      },
      (err) => {
        console.error(err);
        msg.textContent = "‚ö†Ô∏è Load error";
        log(`Error: ${err?.message || err}`);
      }
    );
  }
  loadModel();

  /* ===== Render ===== */
  addEventListener("resize", () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
  (function animate(){
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  })();

  window.addEventListener('error', e=>{ msg.textContent='‚ùå '+(e.message||'Script error'); console.error(e); });
  </script>
<script id="playbook" type="application/json">{"metadata": {"version": "0.1", "units": "degrees", "force_scale": [0, 1, 2, 3, 4, 5]}, "postures": {"supine": [{"key": "hi_fe_l", "deg": 0}, {"key": "hi_fe_r", "deg": 0}, {"key": "kn_fe_l", "deg": 0}, {"key": "kn_fe_r", "deg": 0}, {"key": "sp_flex", "deg": 0}], "prone": [{"key": "hi_fe_l", "deg": -10}, {"key": "hi_fe_r", "deg": -10}, {"key": "sp_flex", "deg": 0}], "sitting": [{"key": "hi_fe_l", "deg": 90}, {"key": "hi_fe_r", "deg": 90}, {"key": "kn_fe_l", "deg": 90}, {"key": "kn_fe_r", "deg": 90}, {"key": "sp_flex", "deg": 10}]}, "tests": {"gh_flex_l": {"posture": "standing", "sequence": [{"type": "move", "key": "sc_up_l", "deg": 10, "ms": 250, "optional": true}, {"type": "move", "key": "gh_fe_l", "deg": 90, "ms": 700}]}, "gh_ext_l": {"posture": "standing", "sequence": [{"type": "move", "key": "sc_down_l", "deg": 5, "ms": 250, "optional": true}, {"type": "move", "key": "gh_fe_l", "deg": -30, "ms": 600}]}, "gh_flex_r": {"inherits": "gh_flex_l", "mirror": true}, "gh_ext_r": {"inherits": "gh_ext_l", "mirror": true}, "el_flex_l": {"posture": "standing", "sequence": [{"type": "move", "key": "el_fe_l", "deg": -90, "ms": 500}]}, "el_ext_l": {"posture": "standing", "sequence": [{"type": "move", "key": "el_fe_l", "deg": 0, "ms": 400}]}, "el_flex_r": {"inherits": "el_flex_l", "mirror": true}, "el_ext_r": {"inherits": "el_ext_l", "mirror": true}, "fa_pro_l": {"posture": "sitting", "sequence": [{"type": "call", "name": "el_flex_l"}, {"type": "move", "key": "fa_ps_l", "deg": 90, "ms": 600}]}, "fa_sup_l": {"posture": "sitting", "sequence": [{"type": "call", "name": "el_flex_l"}, {"type": "move", "key": "fa_ps_l", "deg": -90, "ms": 600}]}, "fa_pro_r": {"inherits": "fa_pro_l", "mirror": true}, "fa_sup_r": {"inherits": "fa_sup_l", "mirror": true}, "cv_flex": {"posture": "sitting", "sequence": [{"type": "move", "key": "cv_fe", "deg": 30, "ms": 500}]}, "cv_ext": {"posture": "sitting", "sequence": [{"type": "move", "key": "cv_fe", "deg": -30, "ms": 500}]}, "cv_lat_l": {"posture": "sitting", "sequence": [{"type": "move", "key": "cv_lat", "deg": 30, "ms": 500}]}, "cv_lat_r": {"posture": "sitting", "sequence": [{"type": "move", "key": "cv_lat", "deg": -30, "ms": 500}]}, "an_df_l": {"posture": "sitting", "sequence": [{"type": "move", "key": "an_df_l", "deg": 15, "ms": 400}]}, "an_pf_l": {"posture": "sitting", "sequence": [{"type": "move", "key": "an_df_l", "deg": -40, "ms": 500}]}, "an_df_r": {"inherits": "an_df_l", "mirror": true}, "an_pf_r": {"inherits": "an_pf_l", "mirror": true}}}</script>

</body>
</html>
